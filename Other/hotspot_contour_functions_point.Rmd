---
title: "hotspot_contour_functions"
output: pdf_document
date: "2025-04-02"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## General
```{r}
## libraries
library(dplyr)
library(ggplot2)
library(lidaRtRee)
library(sf)
library(purrr)

## data
set.seed(1)
df <- data.frame(x = 2*c(abs(rnorm(200)), abs(rnorm(200,4))), y = c(abs(rnorm(200)), abs(rnorm(200,4))))

```


## Bounded hotspots
```{r}
bounded_hotspots = function(df, minimum){
  # create a plot using filled argument
  point.plot = ggplot(df, aes(x = x, y = y)) +
    geom_density_2d_filled(contour = TRUE, breaks = c(minimum, 1))
  
  # extracting information from the plot
  ld.df = layer_data(point.plot)
  
  # separating the different polygons based on subgroup
  ld.df$pol <- paste0(ld.df$subgroup, "_", ld.df$group)
  ids <- unique(ld.df$pol)
  
  # Split contours based on the id
  pols <- lapply(ids, function(x){
    topol <- ld.df[ld.df$pol == x, ]
    closepol <- rbind(topol, topol[1, ])
    pol <- st_polygon(list(as.matrix(closepol[,c("x", "y")])))
    df <- unique(topol[, grepl("level", names(topol))])
    tofeatures <- st_as_sf(df, geometry=st_sfc(pol))
    return(tofeatures)
  })
  
  final_pols <- do.call(rbind, pols)
  
  # gets no overlapping, separate polygons
  parts <- st_cast(st_union(final_pols),"POLYGON")
  clust <- unlist(st_intersects(final_pols, parts))
  
  diss <- cbind(final_pols, clust) %>%
    group_by(clust) %>%
    summarize()

  return(diss)
}


bh = bounded_hotspots(df, 0.05)
plot(bh, axes = TRUE)
```



## Unbounded hotspots
```{r}
# function to extend the plot, so hotspots are not cut off at the borders
d2d = function(data, var1, var2, exp=0.1, minimum) {
  nn = 2
  # Create plot, but expand x and y ranges well beyond data
  p=ggplot(data, aes_string(var1, var2)) +
    geom_density_2d() +
    scale_x_continuous(limits=c(min(data[,var1]) - nn*diff(range(data[,var1])),
                                max(data[,var1]) + nn*diff(range(data[,var1])))) +
    scale_y_continuous(limits=c(min(data[,var2]) - nn*diff(range(data[,var2])),
                                max(data[,var2]) + nn*diff(range(data[,var2]))))
  
  # Get min and max x and y values among all density contours
  pb = ggplot_build(p)

  xyscales = lapply(pb$data[[1]][,c("x","y")], function(var) {
    rng = range(var) 
    rng + c(-exp*diff(rng), exp*diff(rng))
  })

  # Set x and y ranges to include complete density contours
  gg = ggplot(data, aes_string(var1, var2)) +
    #geom_density_2d_filled() +
    geom_density_2d_filled(contour = TRUE,breaks = c(minimum, 1)) +
    geom_density_2d() + #bins = 10) +
    scale_x_continuous(limits=xyscales[[1]]) +
    scale_y_continuous(limits=xyscales[[2]]) 
  return(gg)
}

unbounded_hotspots = function(df, minimum) {
  df.plot = d2d(df, "x","y", minimum = minimum) # minimum is the defined border of the 

  # extracting information from the plot
  ld.df = layer_data(df.plot)
  
  
  # separating the different polygons based on subgroup
  ld.df$pol <- paste0(ld.df$subgroup, "_", ld.df$group)
  ids <- unique(ld.df$pol)
  
  # Split contours based on the id
  pols <- lapply(ids, function(x){
    topol <- ld.df[ld.df$pol == x, ]
    closepol <- rbind(topol, topol[1, ])
    pol <- st_polygon(list(as.matrix(closepol[,c("x", "y")])))
    df <- unique(topol[, grepl("level", names(topol))])
    tofeatures <- st_as_sf(df, geometry=st_sfc(pol))
    return(tofeatures)
  })
  
  
  final_pols <- do.call(rbind, pols)
  
  # gets no overlapping, separate polygons, yay!
  parts <- st_cast(st_union(final_pols),"POLYGON")
  plot(parts) 
  
  clust <- unlist(st_intersects(final_pols, parts))
  
  diss <- cbind(final_pols, clust) %>%
    group_by(clust) %>%
    summarize()
}

bh2 = unbounded_hotspots(df, 0.05)


```


## testing
```{r}
minimum = 0.05
bh = unbounded_hotspots(df, minimum)
bh2 = bounded_hotspots(df, minimum)

plot(bh$geometry, axes = TRUE, col = "blue", main = paste("minimum:", minimum))
plot(bh2$geometry, add = TRUE, axes = TRUE, col = "green")

```

## scale and center function
```{r}
scale.center.poly = function(polygon){
  # calculate centroid and center on origin
  centroid = st_centroid(polygon)
  c.polygon = polygon - centroid
  
  # calculate area and rescale
  area = st_area(polygon)
  sc.polygon = c.polygon * sqrt(1/area)
  
  return(sc.polygon)
  
}

sc1 = scale.center.poly(bh2$geometry[1])
plot(sc1, axes = TRUE)

coordinates(sc1)
```






















