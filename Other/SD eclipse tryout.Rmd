---
title: "Ripley's K variations"
output: pdf_document
date: "2025-03-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Ripley's k function
```{r}
small_points <- cbind(
  x = c(2.5, 3.5, 7.2, 1.5),
  y = c(6.2, 3.8, 4.4, 2.1))


### Method 1: mask grid
# note that r has to be set beforehand, grid resolution
grid_mask = mask_grid(small_points, r = 1, plot = TRUE)

library('spatstat')

X = ppp(small_points[,1], small_points[,2], c(min(small_points[,1]), max(small_points[,1])), c(min(small_points[,2]), max(small_points[,2])), unitname = c("metre","metres"))
plot(X)

X$window

K <- Kest(small_points)
plot(K, main=NULL, las=1, legendargs=list(cex=0.8, xpd=TRUE)) 
```



## point similarity analysis of cross-k functions
```{r}
library("remotes")
install_version("spatstat.core","2.3.1")


```


## interesting stuff
```{r}
# for  a minimum enclosing rectangle
small_points <- cbind(
  x = c(2.5, 3.5, 7.2, 1.5),
  y = c(6.2, 3.8, 4.4, 2.1))


### Method 1: mask grid
# note that r has to be set beforehand, grid resolution
grid_mask = mask_grid(small_points, r = 1, plot = TRUE)

library('spatstat')

X = ppp(small_points[,1], small_points[,2], c(min(small_points[,1]), max(small_points[,1])), c(min(small_points[,2]), max(small_points[,2])), unitname = c("metre","metres"))
plot(X)

X$window



###### or an circle
X = ppp(small_points[,1], small_points[,2], disc(5))
plot(X)

X$window

###### or an ellipse
X = ppp(small_points[,1], small_points[,2], ellipse(5, 2))
plot(X)

X$window




library("phonTools")
##### sd ellipse
plot(small_points, asp = 1); sdellipse(small_points)

library("aspace")
sde = calc_sde(points = small_points, id= 1)

1/tan(sde$ATTRIBUTES$Theta)


plot(small_points, asp = 1, ylim = c(0, 8)); sdellipse(small_points)
abline(4.125-0.27*3.675, 0.27, col = "red") # calculation is y = b + a*x, with b being missing, x,y center of ellipse and a the slope based on the angle of 74.5
points(3.675,4.125, col = "green")

```


```{r}
yy = 4.125
xx = 3.675

1/tan(180-74.5)

1- (yy/(abs(yy/atan(180-74.5))+xx))



((abs((4.1/tan(74.5))) + 3.7))/4.1



A = sde$ATTRIBUTES$Sigma.y
B = sde$ATTRIBUTES$Sigma.x
C = sqrt(A^2 - B^2)

Area = pi*A*B # right
ecc = sqrt(1 - B^2/A^2) # right, so ABC must be correctly calculated

0.5*atan2(B,A-C)
atan2((C-A), -B)/2

0.5*atan(B/(A-C))

angle = atan((C - A + sqrt((C - A)^2 + B^2)) / B)



cos(angle)
(A-C)/sqrt((A-C)^2 + 2*B^2)

pi/4


0.5*atan2(C-A, 2*B)


xx = 4.1/tan(15.5* pi/180) # 90 - 74.5 = 15.54
4.1/abs(xx)


4.125-(0.27*3.67)
```





```{r}
np <- cbind(
  x = c(2,2,3,3,3,4,4),
  y = c(2,3,2,3,4,3,4))

sde = calc_sde(points = np, id= 1)

sde$ATTRIBUTES$Theta # 45
sde$ATTRIBUTES$CENTRE.x
sde$ATTRIBUTES$CENTRE.y

xx = 3/tan(45 * pi/180) 
3/abs(xx)

3-(1.619775*3)

plot(np, asp = 1, ylim = c(0, 8)); sdellipse(np)
abline(3-1*3, 1, col = "red") # calculation is y = b + a*x, with b being missing, x,y center of ellipse and a the slope based on the angle of 74.5
points(3,3, col = "green")



```


```{r}
np <- cbind(
  x = c(2,3,4,2,4),
  y = c(1,2,3,4.5,-0.5))

sde = calc_sde(points = np, id= 1)

sde$ATTRIBUTES$Theta # 45
sde$ATTRIBUTES$CENTRE.x
sde$ATTRIBUTES$CENTRE.y

xx = 3/tan(45 * pi/180) 
3/abs(xx)

3-(1.619775*3)

plot(np, asp = 1, ylim = c(0, 8)); sdellipse(np)
abline(3-1*3, 1, col = "red") # calculation is y = b + a*x, with b being missing, x,y center of ellipse and a the slope based on the angle of 74.5
points(3,3, col = "green")

180-165+90
45-180+90
165-180
```


```{r}
small_points <- cbind(
  y = c(6.2, 3.8, 4.4, 2.1),
  x = c(2.5, 3.5, 7.2, 1.5))

sde = calc_sde(points = small_points, id= 1)
sde$ATTRIBUTES

plot(small_points, asp = 1, ylim = c(0, 8)); sdellipse(small_points)
abline(4.125-1/0.27*3.675, 1/0.27, col = "red") # calculation is y = b + a*x, with b being missing, x,y center of ellipse and a the slope based on the angle of 74.5
points(3.675,4.125, col = "green")
```


Alright so a few points:
- does not provide the right angles from the code, so have to correct (angle < 90 then 90-angle, if above 90 then angle - 270)

```{r}
#data
og <- cbind(
  x = c(2.5, 3.5, 7.2, 1.5),
  y = c(6.2, 3.8, 4.4, 2.1))

### Method 1: mask grid
# note that r has to be set beforehand, grid resolution
sf = mask_grid(small_points, r = 1, plot = TRUE)
sf = cbind(sf[,2], sf[,1]) # because columns in wrong order

ecl_orientation = function(safe, original){
  sde.o = calc_sde(points = small_points, id = 1)
  sde.s = calc_sde(points = small_points, id = 2)
  
  angles = c(sde.o$ATTRIBUTES$Theta, sde.s$ATTRIBUTES$Theta) #angles of original and safe
  ifelse(angles < 90, 90 - angles, ifelse(angles > 90, abs(angles - 240)), angles) # correct angles to obtain intuitive angle
  
  ## plotting the ellipses and their angles (red) and midpoints (green)
  
  
  sde$ATTRIBUTES$Theta # 45
sde$ATTRIBUTES$CENTRE.x
sde$ATTRIBUTES$CENTRE.y

xx = 3/tan(45 * pi/180) 
3/abs(xx)

3-(1.619775*3)

plot(np, asp = 1, ylim = c(0, 8)); sdellipse(np); sdellipse(small_points)
abline(3-1*3, 1, col = "red") # calculation is y = b + a*x, with b being missing, x,y center of ellipse and a the slope based on the angle of 74.5
points(3,3, col = "green")
  
  return(angles)
}

plot_sde(sde);sdellipse(small_points);abline(0,1)
```



```{r}

```



























































