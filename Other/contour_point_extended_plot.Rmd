---
title: "another contour file"
output: pdf_document
date: "2025-03-27"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##  the original
https://stackoverflow.com/questions/35974805/ggplot2-automatic-scaling-to-include-complete-contour-lines-in-geom-density-2d
```{r}
d2d = function(data, var1, var2, col, exp=0.00) {

  # If the colour variable is numeric, convert to factor
  if(is.numeric(data[,col])) {
    data[,col] = as.factor(data[,col])
  }

  # Create plot, but expand x and y ranges well beyond data
  p=ggplot(data, aes_string(var1, var2, colour=col)) +
    geom_density_2d() +
    scale_x_continuous(limits=c(min(data[,var1]) - 2*diff(range(data[,var1])),
                                max(data[,var1]) + 2*diff(range(data[,var1])))) +
    scale_y_continuous(limits=c(min(data[,var2]) - 2*diff(range(data[,var2])),
                                max(data[,var2]) + 2*diff(range(data[,var2]))))

  # Get min and max x and y values among all density contours
  pb = ggplot_build(p)

  xyscales = lapply(pb$data[[1]][,c("x","y")], function(var) {
    rng = range(var)
    rng + c(-exp*diff(rng), exp*diff(rng))
  })

  # Set x and y ranges to include complete density contours
  ggplot(data, aes_string(var1, var2, colour=col)) +
    geom_density_2d() +
    scale_x_continuous(limits=xyscales[[1]]) +
    scale_y_continuous(limits=xyscales[[2]]) 
}


d2d(mtcars, "wt","mpg", "cyl")

```

## now for our data
```{r}
d2d = function(data, var1, var2, exp=0.1) {
  nn = 2
  # Create plot, but expand x and y ranges well beyond data
  p=ggplot(data, aes_string(var1, var2)) +
    geom_density_2d() +
    scale_x_continuous(limits=c(min(data[,var1]) - nn*diff(range(data[,var1])),
                                max(data[,var1]) + nn*diff(range(data[,var1])))) +
    scale_y_continuous(limits=c(min(data[,var2]) - nn*diff(range(data[,var2])),
                                max(data[,var2]) + nn*diff(range(data[,var2]))))
  
  # Get min and max x and y values among all density contours
  pb = ggplot_build(p)

  xyscales = lapply(pb$data[[1]][,c("x","y")], function(var) {
    rng = range(var) 
    rng + c(-exp*diff(rng), exp*diff(rng))
  })

  # Set x and y ranges to include complete density contours
  ggplot(data, aes_string(var1, var2)) +
    geom_density_2d_filled() +
    geom_density_2d(bins = 10) +
    scale_x_continuous(limits=xyscales[[1]]) +
    scale_y_continuous(limits=xyscales[[2]]) 
}

set.seed(123)
df <- data.frame(x = c(abs(rnorm(200)), abs(rnorm(200,4))), y = c(abs(rnorm(200)), abs(rnorm(200,4))))


df.plot = d2d(df, "x","y")
d2d(df, "x","y")

# alright so now we have the plot, but we still need the polygons, and they need to be cut to the right size
```

## extracting the polygons
```{r}
ld.df = layer_data(df.plot)
ld.df = ld.df[ld.df$level == "(0.03, 0.04]",] #

ld.df$pol <- paste0(ld.df$subgroup)
ids <- unique(ld.df$pol)

# Split contours based on the id
pols <- lapply(ids, function(x){
  topol <- ld.df[which(ld.df$pol == x), c("x","y")]
  closepol <- as.matrix(rbind(topol, topol[1, ]))
  return((closepol))
})

# convert to polygons and plot
cont2 = pointList2poly(pols)
plot(cont2[2], axes = TRUE) # only the contours
plot(cont2, axes = TRUE) # with colors

```

Using features in the pols function
https://gis.stackexchange.com/questions/323038/dissolve-only-overlapping-polygons-in-r-using-sf
```{r}
library(dplyr)
ld.df = layer_data(df.plot)
ld.df = ld.df[ld.df$level == "(0.03, 0.04]",] #

ld.df$pol <- paste0(ld.df$subgroup)
ids <- unique(ld.df$pol)

# Split contours based on the id
pols <- lapply(ids, function(x){
  topol <- ld.df[ld.df$pol == x, ]
  
  closepol <- rbind(topol, topol[1, ])

  pol <- st_polygon(list(as.matrix(closepol[,c("x", "y")])))
  
  # Add features
  df <- unique(topol[, grepl("level", names(topol))])
  
  tofeatures <- st_as_sf(df, geometry=st_sfc(pol))
  return(tofeatures)
})


final_pols <- do.call(rbind, pols)

# now something else
parts <- st_cast(st_union(final_pols),"POLYGON")
plot(parts) # gets no overlapping, separate polygons, yay!

clust <- unlist(st_intersects(final_pols, parts))

diss <- cbind(final_pols, clust) %>%
  group_by(clust) %>%
  summarize(box = paste(nlevel, collapse = ", "))

plot(diss[1])
plot(diss[2])
plot(diss[3])

```














## cutting the polygons to the right size
```{r}

```


















